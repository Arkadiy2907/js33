// 1) Какие бывают алгоритмы сортировок ?
// 2) Прочитать про "Операторы и выражения, циклы в JS"
// 3) Создать объект Person несколькими способами,
//  после создать объект Person2, чтобы в нём были доступны методы объекта Person.
//  Добавить метод logInfo чтоб он был доступен всем объектам.
// 4) Создать класс PersonThree c get и set для поля name и конструктором,
//  сделать класс наследник от класса Person.

// БОНУС:
// 1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

// arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
// total = 13;
// //result = [4, 9]

// const firstSum = (arr, total) => {
//       //Решение
// }

// firstSum(arr,total)

// 2) Какая сложность у вашего алгоритма ?
// ======================================================================

// 1) Какие бывают алгоритмы сортировок ?

// Сортировка выбором – делается проход по массиву от начала до конца в поиске минимального элемента массива и перемещении его в начало. Сложность O(n^2).

const selectedSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    let min = i;

    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        min = j;
      }
    }

    [arr[i], arr[min]] = [arr[min], arr[i]];
  }

  return arr;
};

console.log(selectedSort([2, 1, 3, 7, 5]));

// Сортировка пузырьком – алгоритм меняет местами два соседних элемента, если первый элемент массива больше второго. Так происходит до тех пор, пока алгоритм не обменяет местами все неотсортированные элементы. Сложность O(n^2).

const bubbleSort = (arr) => {
  for (let n = 0; n < arr.length; n++) {
    for (let i = 0; i < arr.length - 1 - n; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
      }
    }
  }

  return arr;
};

// Сортировка вставками - разбиваем массив на отсортированную и неотсортированную части. Берём элемент из неотсортированной и вставляем его на своё место в отсортированную часть массива. Алгоритм работает до тех пор, пока в неотсортированной части есть элементы. Сложность O(n^2)

// Быстрая сортировка - выделяем в массиве опорный элемент и разбиваем массив на две части: в одной числа меньше опорного элемента, в другой –– больше. Затем рекурсивно вызываем алгоритм на двух выделенных группах и соединяем левую и правую части с опорным элементом в конечный результат. Сложность O(n^2)

// Сортировка слиянием - разбиваем массив на две равные части, сортируем каждую из них отдельно и соединяем две отсортированные части в одну. Сложность O(n*log(n))

// ------------------------------------------
// 3) Создать объект Person несколькими способами,
//  после создать объект Person2, чтобы в нём были доступны методы объекта Person.
//  Добавить метод logInfo чтоб он был доступен всем объектам.

// ------------------------------------------
// 4) Создать класс PersonThree c get и set для поля name и конструктором,
//  сделать класс наследник от класса Person.

// ------------------------------------------

// БОНУС:
// 1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
//result = [4, 9]

const isCheckArg = (arr, total) => {
  if (
    !Array.isArray(arr) ||
    arr.filter(
      (el) => typeof el !== 'number' || isNaN(el) || !Number.isInteger(el)
    ).length > 0 ||
    arr.length < 2
  ) {
    throw new TypeError('bad arguments: arr');
  }

  if (typeof total !== 'number' || isNaN(total) || !Number.isInteger(total)) {
    throw new TypeError('bad arguments: total');
  }
};

//решение "в лоб". Сложность O(n^2)

const firstSum = (arr, total) => {
  isCheckArg(arr, total);

  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] + arr[i] === total) {
        return [arr[i], arr[j]];
      }
    }
  }

  return 'please change arg';
};

console.log(firstSum(arr, total)); // [4, 9]

//сложность O((n log n) с использованием метода sort.
// если же массив изначально отсортирован
// то для алгоритма "Два указателя"(Two Pointers) сложность O(n)

const firstSum1 = (arr, total) => {
  isCheckArg(arr, total);

  arr.sort((a, b) => a - b);

  let left = 0;
  let right = arr.length - 1;

  while (left < right) {
    const sum = arr[left] + arr[right];
    if (sum === total) {
      return [arr[left], arr[right]];
    } else if (sum < total) {
      left++;
    } else {
      right--;
    }
  }

  return 'please change arg';
};

console.log(firstSum1(arr, total)); // [ 4, 9 ]
